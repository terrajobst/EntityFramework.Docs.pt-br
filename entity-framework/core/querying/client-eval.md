---
title: Avaliação cliente vs. Servidor - EF Core
author: smitpatel
ms.date: 10/03/2019
ms.assetid: 8b6697cc-7067-4dc2-8007-85d80503d123
uid: core/querying/client-eval
ms.openlocfilehash: e01bd146c4dfe7a8d36b641cb52ae366fddd8239
ms.sourcegitcommit: 9b562663679854c37c05fca13d93e180213fb4aa
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/07/2020
ms.locfileid: "78417756"
---
# <a name="client-vs-server-evaluation"></a><span data-ttu-id="1adb5-102">Avaliação cliente vs. Servidor</span><span class="sxs-lookup"><span data-stu-id="1adb5-102">Client vs. Server Evaluation</span></span>

<span data-ttu-id="1adb5-103">Como regra geral, o Entity Framework Core tenta avaliar uma consulta no servidor o máximo possível.</span><span class="sxs-lookup"><span data-stu-id="1adb5-103">As a general rule, Entity Framework Core attempts to evaluate a query on the server as much as possible.</span></span> <span data-ttu-id="1adb5-104">O EF Core converte partes da consulta em parâmetros, que ele pode avaliar no lado do cliente.</span><span class="sxs-lookup"><span data-stu-id="1adb5-104">EF Core converts parts of the query into parameters, which it can evaluate on the client side.</span></span> <span data-ttu-id="1adb5-105">O restante da consulta (juntamente com os parâmetros gerados) é dado ao provedor de banco de dados para determinar a consulta de banco de dados equivalente para avaliar no servidor.</span><span class="sxs-lookup"><span data-stu-id="1adb5-105">The rest of the query (along with the generated parameters) is given to the database provider to determine the equivalent database query to evaluate on the server.</span></span> <span data-ttu-id="1adb5-106">O EF Core suporta a avaliação parcial do cliente na projeção de nível superior (essencialmente, a última chamada para `Select()`).</span><span class="sxs-lookup"><span data-stu-id="1adb5-106">EF Core supports partial client evaluation in the top-level projection (essentially, the last call to `Select()`).</span></span> <span data-ttu-id="1adb5-107">Se a projeção de nível superior na consulta não puder ser traduzida para o servidor, o EF Core buscará quaisquer dados necessários do servidor e avaliará as partes restantes da consulta no cliente.</span><span class="sxs-lookup"><span data-stu-id="1adb5-107">If the top-level projection in the query can't be translated to the server, EF Core will fetch any required data from the server and evaluate remaining parts of the query on the client.</span></span> <span data-ttu-id="1adb5-108">Se o EF Core detectar uma expressão, em qualquer lugar que não seja a projeção de nível superior, que não pode ser traduzida para o servidor, então ele lança uma exceção de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="1adb5-108">If EF Core detects an expression, in any place other than the top-level projection, which can't be translated to the server, then it throws a runtime exception.</span></span> <span data-ttu-id="1adb5-109">Veja [como a consulta funciona](xref:core/querying/how-query-works) para entender como o EF Core determina o que não pode ser traduzido para servidor.</span><span class="sxs-lookup"><span data-stu-id="1adb5-109">See [how query works](xref:core/querying/how-query-works) to understand how EF Core determines what can't be translated to server.</span></span>

> [!NOTE]
> <span data-ttu-id="1adb5-110">Antes da versão 3.0, o Entity Framework Core suportava a avaliação do cliente em qualquer lugar da consulta.</span><span class="sxs-lookup"><span data-stu-id="1adb5-110">Prior to version 3.0, Entity Framework Core supported client evaluation anywhere in the query.</span></span> <span data-ttu-id="1adb5-111">Para obter mais informações, consulte a [seção versões anteriores](#previous-versions).</span><span class="sxs-lookup"><span data-stu-id="1adb5-111">For more information, see the [previous versions section](#previous-versions).</span></span>

> [!TIP]
> <span data-ttu-id="1adb5-112">Você pode ver a [amostra](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying) deste artigo no GitHub.</span><span class="sxs-lookup"><span data-stu-id="1adb5-112">You can view this article's [sample](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Querying) on GitHub.</span></span>

## <a name="client-evaluation-in-the-top-level-projection"></a><span data-ttu-id="1adb5-113">Avaliação do cliente na projeção de nível superior</span><span class="sxs-lookup"><span data-stu-id="1adb5-113">Client evaluation in the top-level projection</span></span>

<span data-ttu-id="1adb5-114">No exemplo a seguir, um método auxiliar é usado para padronizar URLs para blogs, que são devolvidos a partir de um banco de dados SQL Server.</span><span class="sxs-lookup"><span data-stu-id="1adb5-114">In the following example, a helper method is used to standardize URLs for blogs, which are returned from a SQL Server database.</span></span> <span data-ttu-id="1adb5-115">Como o provedor do SQL Server não tem nenhuma ideia de como esse método é implementado, não é possível traduzi-lo para O SQL.</span><span class="sxs-lookup"><span data-stu-id="1adb5-115">Since the SQL Server provider has no insight into how this method is implemented, it isn't possible to translate it into SQL.</span></span> <span data-ttu-id="1adb5-116">Todos os outros aspectos da consulta são avaliados no banco `URL` de dados, mas a aprovação do retorno através desse método é feita no cliente.</span><span class="sxs-lookup"><span data-stu-id="1adb5-116">All other aspects of the query are evaluated in the database, but passing the returned `URL` through this method is done on the client.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/ClientEval/Sample.cs#ClientProjection)]

[!code-csharp[Main](../../../samples/core/Querying/ClientEval/Sample.cs#ClientMethod)]

## <a name="unsupported-client-evaluation"></a><span data-ttu-id="1adb5-117">Avaliação de clientes sem suporte</span><span class="sxs-lookup"><span data-stu-id="1adb5-117">Unsupported client evaluation</span></span>

<span data-ttu-id="1adb5-118">Embora a avaliação do cliente seja útil, pode resultar em um desempenho ruim às vezes.</span><span class="sxs-lookup"><span data-stu-id="1adb5-118">While client evaluation is useful, it can result in poor performance sometimes.</span></span> <span data-ttu-id="1adb5-119">Considere a seguinte consulta, na qual o método auxiliar é agora usado em um filtro onde.</span><span class="sxs-lookup"><span data-stu-id="1adb5-119">Consider the following query, in which the helper method is now used in a where filter.</span></span> <span data-ttu-id="1adb5-120">Como o filtro não pode ser aplicado no banco de dados, todos os dados precisam ser puxados para a memória para aplicar o filtro no cliente.</span><span class="sxs-lookup"><span data-stu-id="1adb5-120">Because the filter can't be applied in the database, all the data needs to be pulled into memory to apply the filter on the client.</span></span> <span data-ttu-id="1adb5-121">Com base no filtro e na quantidade de dados no servidor, a avaliação do cliente pode resultar em um desempenho ruim.</span><span class="sxs-lookup"><span data-stu-id="1adb5-121">Based on the filter and the amount of data on the server, client evaluation could result in poor performance.</span></span> <span data-ttu-id="1adb5-122">Assim, o Entity Framework Core bloqueia essa avaliação de clientes e lança uma exceção de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="1adb5-122">So Entity Framework Core blocks such client evaluation and throws a runtime exception.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/ClientEval/Sample.cs#ClientWhere)]

## <a name="explicit-client-evaluation"></a><span data-ttu-id="1adb5-123">Avaliação explícita do cliente</span><span class="sxs-lookup"><span data-stu-id="1adb5-123">Explicit client evaluation</span></span>

<span data-ttu-id="1adb5-124">Você pode precisar forçar a avaliação do cliente explicitamente em certos casos como seguir</span><span class="sxs-lookup"><span data-stu-id="1adb5-124">You may need to force into client evaluation explicitly in certain cases like following</span></span>

- <span data-ttu-id="1adb5-125">A quantidade de dados é pequena para que a avaliação no cliente não incorra em uma grande penalidade de desempenho.</span><span class="sxs-lookup"><span data-stu-id="1adb5-125">The amount of data is small so that evaluating on the client doesn't incur a huge performance penalty.</span></span>
- <span data-ttu-id="1adb5-126">O operador LINQ que está sendo usado não tem tradução do lado do servidor.</span><span class="sxs-lookup"><span data-stu-id="1adb5-126">The LINQ operator being used has no server-side translation.</span></span>

<span data-ttu-id="1adb5-127">Nesses casos, você pode optar explicitamente pela avaliação `AsEnumerable` do `ToList` `AsAsyncEnumerable` cliente `ToListAsync` ligando para métodos como ou (ou para assincronismo).</span><span class="sxs-lookup"><span data-stu-id="1adb5-127">In such cases, you can explicitly opt into client evaluation by calling methods like `AsEnumerable` or `ToList` (`AsAsyncEnumerable` or `ToListAsync` for async).</span></span> <span data-ttu-id="1adb5-128">Ao `AsEnumerable` usar você estaria transmitindo os `ToList` resultados, mas usar causaria buffering criando uma lista, que também leva memória adicional.</span><span class="sxs-lookup"><span data-stu-id="1adb5-128">By using `AsEnumerable` you would be streaming the results, but using `ToList` would cause buffering by creating a list, which also takes additional memory.</span></span> <span data-ttu-id="1adb5-129">Embora se você estiver enumerando várias vezes, então armazenar resultados em uma lista ajuda mais, já que há apenas uma consulta ao banco de dados.</span><span class="sxs-lookup"><span data-stu-id="1adb5-129">Though if you're enumerating multiple times, then storing results in a list helps more since there's only one query to the database.</span></span> <span data-ttu-id="1adb5-130">Dependendo do uso específico, você deve avaliar qual método é mais útil para o caso.</span><span class="sxs-lookup"><span data-stu-id="1adb5-130">Depending on the particular usage, you should evaluate which method is more useful for the case.</span></span>

[!code-csharp[Main](../../../samples/core/Querying/ClientEval/Sample.cs#ExplicitClientEval)]

## <a name="potential-memory-leak-in-client-evaluation"></a><span data-ttu-id="1adb5-131">Vazamento potencial de memória na avaliação do cliente</span><span class="sxs-lookup"><span data-stu-id="1adb5-131">Potential memory leak in client evaluation</span></span>

<span data-ttu-id="1adb5-132">Uma vez que a tradução e a compilação da consulta são caras, o EF Core armazena o plano de consulta compilado.</span><span class="sxs-lookup"><span data-stu-id="1adb5-132">Since query translation and compilation are expensive, EF Core caches the compiled query plan.</span></span> <span data-ttu-id="1adb5-133">O delegado armazenado em cache pode usar o código do cliente enquanto faz a avaliação do cliente de projeção de nível superior.</span><span class="sxs-lookup"><span data-stu-id="1adb5-133">The cached delegate may use client code while doing client evaluation of top-level projection.</span></span> <span data-ttu-id="1adb5-134">O EF Core gera parâmetros para as partes avaliadas pelo cliente da árvore e reutiliza o plano de consulta substituindo os valores dos parâmetros.</span><span class="sxs-lookup"><span data-stu-id="1adb5-134">EF Core generates parameters for the client-evaluated parts of the tree and reuses the query plan by replacing the parameter values.</span></span> <span data-ttu-id="1adb5-135">Mas certas constantes na árvore de expressão não podem ser convertidas em parâmetros.</span><span class="sxs-lookup"><span data-stu-id="1adb5-135">But certain constants in the expression tree can't be converted into parameters.</span></span> <span data-ttu-id="1adb5-136">Se o delegado armazenado contém tais constantes, então esses objetos não podem ser coletados lixo, pois ainda estão sendo referenciados.</span><span class="sxs-lookup"><span data-stu-id="1adb5-136">If the cached delegate contains such constants, then those objects can't be garbage collected since they're still being referenced.</span></span> <span data-ttu-id="1adb5-137">Se tal objeto contiver um DbContext ou outros serviços nele, então ele pode fazer com que o uso da memória do aplicativo cresça com o tempo.</span><span class="sxs-lookup"><span data-stu-id="1adb5-137">If such an object contains a DbContext or other services in it, then it could cause the memory usage of the app to grow over time.</span></span> <span data-ttu-id="1adb5-138">Esse comportamento é geralmente um sinal de um vazamento de memória.</span><span class="sxs-lookup"><span data-stu-id="1adb5-138">This behavior is generally a sign of a memory leak.</span></span> <span data-ttu-id="1adb5-139">O EF Core abre uma exceção sempre que se depara com constantes de um tipo que não pode ser mapeado usando o provedor de banco de dados atual.</span><span class="sxs-lookup"><span data-stu-id="1adb5-139">EF Core throws an exception whenever it comes across constants of a type that can't be mapped using current database provider.</span></span> <span data-ttu-id="1adb5-140">Causas comuns e suas soluções são as seguintes:</span><span class="sxs-lookup"><span data-stu-id="1adb5-140">Common causes and their solutions are as follows:</span></span>

- <span data-ttu-id="1adb5-141">**Usando um método de instância**: Ao usar métodos de ocorrência em uma projeção de cliente, a árvore de expressão contém uma constante da instância.</span><span class="sxs-lookup"><span data-stu-id="1adb5-141">**Using an instance method**: When using instance methods in a client projection, the expression tree contains a constant of the instance.</span></span> <span data-ttu-id="1adb5-142">Se o seu método não usar nenhum dado da instância, considere tornar o método estático.</span><span class="sxs-lookup"><span data-stu-id="1adb5-142">If your method doesn't use any data from the instance, consider making the method static.</span></span> <span data-ttu-id="1adb5-143">Se você precisar de dados de instância no corpo do método, então passe os dados específicos como um argumento para o método.</span><span class="sxs-lookup"><span data-stu-id="1adb5-143">If you need instance data in the method body, then pass the specific data as an argument to the method.</span></span>
- <span data-ttu-id="1adb5-144">**Passando argumentos constantes para o método**: `this` Este caso surge geralmente usando em um argumento para o método do cliente.</span><span class="sxs-lookup"><span data-stu-id="1adb5-144">**Passing constant arguments to method**: This case arises generally by using `this` in an argument to client method.</span></span> <span data-ttu-id="1adb5-145">Considere dividir o argumento em vários argumentos escalares, que podem ser mapeados pelo provedor de banco de dados.</span><span class="sxs-lookup"><span data-stu-id="1adb5-145">Consider splitting the argument in to multiple scalar arguments, which can be mapped by the database provider.</span></span>
- <span data-ttu-id="1adb5-146">**Outras constantes**: Se uma constante é vista em qualquer outro caso, então você pode avaliar se a constante é necessária no processamento.</span><span class="sxs-lookup"><span data-stu-id="1adb5-146">**Other constants**: If a constant is come across in any other case, then you can evaluate whether the constant is needed in processing.</span></span> <span data-ttu-id="1adb5-147">Se for necessário ter a constante, ou se você não puder usar uma solução dos casos acima, então crie uma variável local para armazenar o valor e usar a variável local na consulta.</span><span class="sxs-lookup"><span data-stu-id="1adb5-147">If it's necessary to have the constant, or if you can't use a solution from the above cases, then create a local variable to store the value and use local variable in the query.</span></span> <span data-ttu-id="1adb5-148">O EF Core converterá a variável local em um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="1adb5-148">EF Core will convert the local variable into a parameter.</span></span>

## <a name="previous-versions"></a><span data-ttu-id="1adb5-149">Versões anteriores</span><span class="sxs-lookup"><span data-stu-id="1adb5-149">Previous versions</span></span>

<span data-ttu-id="1adb5-150">A seção a seguir se aplica às versões EF Core antes do 3.0.</span><span class="sxs-lookup"><span data-stu-id="1adb5-150">The following section applies to EF Core versions before 3.0.</span></span>

<span data-ttu-id="1adb5-151">Versões mais antigas do EF Core suportavam avaliação de clientes em qualquer parte da consulta - não apenas a projeção de nível superior.</span><span class="sxs-lookup"><span data-stu-id="1adb5-151">Older EF Core versions supported client evaluation in any part of the query--not just the top-level projection.</span></span> <span data-ttu-id="1adb5-152">É por isso que consultas semelhantes a uma postada na seção [de avaliação de clientes sem suporte](#unsupported-client-evaluation) funcionaram corretamente.</span><span class="sxs-lookup"><span data-stu-id="1adb5-152">That's why queries similar to one posted under the [Unsupported client evaluation](#unsupported-client-evaluation) section worked correctly.</span></span> <span data-ttu-id="1adb5-153">Como esse comportamento pode causar problemas de desempenho despercebidos, o EF Core registrou um aviso de avaliação do cliente.</span><span class="sxs-lookup"><span data-stu-id="1adb5-153">Since this behavior could cause unnoticed performance issues, EF Core logged a client evaluation warning.</span></span> <span data-ttu-id="1adb5-154">Para obter mais informações sobre como visualizar a saída de registro, consulte [Registrar](xref:core/miscellaneous/logging).</span><span class="sxs-lookup"><span data-stu-id="1adb5-154">For more information on viewing logging output, see [Logging](xref:core/miscellaneous/logging).</span></span>

<span data-ttu-id="1adb5-155">Opcionalmente, o EF Core permitiu que você alterasse o comportamento padrão para lançar uma exceção ou não fazer nada ao fazer avaliação do cliente (exceto na projeção).</span><span class="sxs-lookup"><span data-stu-id="1adb5-155">Optionally EF Core allowed you to change the default behavior to either throw an exception or do nothing when doing client evaluation (except for in the projection).</span></span> <span data-ttu-id="1adb5-156">O comportamento de arremesso de exceção o tornaria semelhante ao comportamento em 3.0.</span><span class="sxs-lookup"><span data-stu-id="1adb5-156">The exception throwing behavior would make it similar to the behavior in 3.0.</span></span> <span data-ttu-id="1adb5-157">Para alterar o comportamento, você precisa configurar avisos enquanto configura as `DbContext.OnConfiguring`opções `Startup.cs` para o seu contexto - normalmente em - ou em se você estiver usando ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="1adb5-157">To change the behavior, you need to configure warnings while setting up the options for your context - typically in `DbContext.OnConfiguring`, or in `Startup.cs` if you're using ASP.NET Core.</span></span>

```csharp
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder
        .UseSqlServer(@"Server=(localdb)\mssqllocaldb;Database=EFQuerying;Trusted_Connection=True;")
        .ConfigureWarnings(warnings => warnings.Throw(RelationalEventId.QueryClientEvaluationWarning));
}
```
