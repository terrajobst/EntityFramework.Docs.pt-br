---
title: Trabalhando com tipos de referência anuláveis-EF Core
author: roji
ms.date: 09/09/2019
ms.assetid: bde4e0ee-fba3-4813-a849-27049323d301
uid: core/miscellaneous/nullable-reference-types
ms.openlocfilehash: c16a475c363320cd18804a4efe78ccae1ae22f0d
ms.sourcegitcommit: cc0ff36e46e9ed3527638f7208000e8521faef2e
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 03/06/2020
ms.locfileid: "78416651"
---
# <a name="working-with-nullable-reference-types"></a><span data-ttu-id="72ba7-102">Trabalhando com tipos de referência anuláveis</span><span class="sxs-lookup"><span data-stu-id="72ba7-102">Working with Nullable Reference Types</span></span>

<span data-ttu-id="72ba7-103">C#8 introduziu um novo recurso chamado [tipos de referência anulável](/dotnet/csharp/tutorials/nullable-reference-types), permitindo que os tipos de referência sejam anotados, indicando se é válido para que eles contenham nulo ou não.</span><span class="sxs-lookup"><span data-stu-id="72ba7-103">C# 8 introduced a new feature called [nullable reference types](/dotnet/csharp/tutorials/nullable-reference-types), allowing reference types to be annotated, indicating whether it is valid for them to contain null or not.</span></span> <span data-ttu-id="72ba7-104">Se você for novo nesse recurso, é recomendável que você se familiarize com ele lendo os C# documentos.</span><span class="sxs-lookup"><span data-stu-id="72ba7-104">If you are new to this feature, it is recommended that make yourself familiar with it by reading the C# docs.</span></span>

<span data-ttu-id="72ba7-105">Esta página apresenta o suporte de EF Core para tipos de referência anuláveis e descreve as práticas recomendadas para trabalhar com eles.</span><span class="sxs-lookup"><span data-stu-id="72ba7-105">This page introduces EF Core's support for nullable reference types, and describes best practices for working with them.</span></span>

## <a name="required-and-optional-properties"></a><span data-ttu-id="72ba7-106">Propriedades obrigatórias e opcionais</span><span class="sxs-lookup"><span data-stu-id="72ba7-106">Required and optional properties</span></span>

<span data-ttu-id="72ba7-107">A documentação principal sobre as propriedades obrigatórias e opcionais e sua interação com tipos de referência anuláveis é a página de [Propriedades obrigatória e opcional](xref:core/modeling/entity-properties#required-and-optional-properties) .</span><span class="sxs-lookup"><span data-stu-id="72ba7-107">The main documentation on required and optional properties and their interaction with nullable reference types is the [Required and Optional Properties](xref:core/modeling/entity-properties#required-and-optional-properties) page.</span></span> <span data-ttu-id="72ba7-108">É recomendável começar lendo essa página primeiro.</span><span class="sxs-lookup"><span data-stu-id="72ba7-108">It is recommended you start out by reading that page first.</span></span>

> [!NOTE]
> <span data-ttu-id="72ba7-109">Tenha cuidado ao habilitar tipos de referência anuláveis em um projeto existente: as propriedades do tipo de referência que foram previamente configuradas como opcionais agora serão configuradas conforme necessário, a menos que sejam anotadas explicitamente para permitir valor nulo.</span><span class="sxs-lookup"><span data-stu-id="72ba7-109">Exercise caution when enabling nullable reference types on an existing project: reference type properties which were previously configured as optional will now be configured as required, unless they are explicitly annotated to be nullable.</span></span> <span data-ttu-id="72ba7-110">Ao gerenciar um esquema de banco de dados relacional, isso pode fazer com que as migrações sejam geradas, alterando a nulidade da coluna do banco de dados.</span><span class="sxs-lookup"><span data-stu-id="72ba7-110">When managing a relational database schema, this may cause migrations to be generated which alter the database column's nullability.</span></span>

## <a name="dbcontext-and-dbset"></a><span data-ttu-id="72ba7-111">DbContext e DbSet</span><span class="sxs-lookup"><span data-stu-id="72ba7-111">DbContext and DbSet</span></span>

<span data-ttu-id="72ba7-112">Quando tipos de referência anuláveis são habilitados, o C# compilador emite avisos para qualquer propriedade não anulável não inicializada, pois eles conteriam NULL.</span><span class="sxs-lookup"><span data-stu-id="72ba7-112">When nullable reference types are enabled, the C# compiler emits warnings for any uninitialized non-nullable property, as these would contain null.</span></span> <span data-ttu-id="72ba7-113">Como resultado, a prática comum de definir um `DbSet` não anulável em um contexto irá gerar um aviso.</span><span class="sxs-lookup"><span data-stu-id="72ba7-113">As a result, the common practice of defining a non-nullable `DbSet` on a context will now generate a warning.</span></span> <span data-ttu-id="72ba7-114">No entanto, EF Core sempre Inicializa todas as propriedades de `DbSet` em tipos derivados de DbContext, para que sejam garantidas nunca serem nulas, mesmo que o compilador não esteja ciente disso.</span><span class="sxs-lookup"><span data-stu-id="72ba7-114">However, EF Core always initializes all `DbSet` properties on DbContext-derived types, so they are guaranteed to never be null, even if the compiler is unaware of this.</span></span> <span data-ttu-id="72ba7-115">Portanto, é recomendável manter suas propriedades `DbSet` não anuláveis, permitindo que você as acesse sem verificações nulas, e para silenciar os avisos do compilador, definindo-os explicitamente como NULL com a ajuda do operador NULL-tolerante (!):</span><span class="sxs-lookup"><span data-stu-id="72ba7-115">Therefore, it is recommended to keep your `DbSet` properties non-nullable - allowing you to access them without null checks - and to silence the compiler warnings by explicitly setting them to null with the help of the null-forgiving operator (!):</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/NullableReferenceTypesContext.cs?name=Context&highlight=3-4)]

## <a name="non-nullable-properties-and-initialization"></a><span data-ttu-id="72ba7-116">Propriedades e inicialização não anuláveis</span><span class="sxs-lookup"><span data-stu-id="72ba7-116">Non-nullable properties and initialization</span></span>

<span data-ttu-id="72ba7-117">Os avisos do compilador para tipos de referência não anuláveis não inicializados também são um problema para propriedades regulares em seus tipos de entidade.</span><span class="sxs-lookup"><span data-stu-id="72ba7-117">Compiler warnings for uninitialized non-nullable reference types are also a problem for regular properties on your entity types.</span></span> <span data-ttu-id="72ba7-118">Em nosso exemplo acima, evitamos esses avisos usando a [Associação de Construtor](xref:core/modeling/constructors), um recurso que funciona perfeitamente com propriedades não anuláveis, garantindo que eles sejam sempre inicializados.</span><span class="sxs-lookup"><span data-stu-id="72ba7-118">In our example above, we avoided these warnings by using [constructor binding](xref:core/modeling/constructors), a feature which works perfectly with non-nullable properties, ensuring they are always initialized.</span></span> <span data-ttu-id="72ba7-119">No entanto, em alguns cenários, a associação de construtor não é uma opção: as propriedades de navegação, por exemplo, não podem ser inicializadas dessa maneira.</span><span class="sxs-lookup"><span data-stu-id="72ba7-119">However, in some scenarios constructor binding isn't an option: navigation properties, for example, cannot be initialized in this way.</span></span>

<span data-ttu-id="72ba7-120">As propriedades de navegação necessárias apresentam uma dificuldade adicional: embora um dependente sempre exista para uma determinada entidade de segurança, ele pode ou não ser carregado por uma consulta específica, dependendo das necessidades nesse ponto do programa ([consulte os diferentes padrões para carregar dados](xref:core/querying/related-data)).</span><span class="sxs-lookup"><span data-stu-id="72ba7-120">Required navigation properties present an additional difficulty: although a dependent will always exist for a given principal, it may or may not be loaded by a particular query, depending on the needs at that point in the program ([see the different patterns for loading data](xref:core/querying/related-data)).</span></span> <span data-ttu-id="72ba7-121">Ao mesmo tempo, não é desejável tornar essas propriedades anuláveis, pois isso forçaria todo o acesso a elas para verificar se há algum valor nulo, mesmo se eles forem necessários.</span><span class="sxs-lookup"><span data-stu-id="72ba7-121">At the same time, it is undesirable to make these properties nullable, since that would force all access to them to check for null, even if they are required.</span></span>

<span data-ttu-id="72ba7-122">Uma maneira de lidar com esses cenários é ter uma propriedade não anulável com um [campo de backup](xref:core/modeling/backing-field)anulável:</span><span class="sxs-lookup"><span data-stu-id="72ba7-122">One way to deal with these scenarios, is to have a non-nullable property with a nullable [backing field](xref:core/modeling/backing-field):</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Order.cs?range=10-17)]

<span data-ttu-id="72ba7-123">Como a propriedade de navegação é não anulável, uma navegação necessária é configurada; e, desde que a navegação seja carregada corretamente, o dependente poderá ser acessado por meio da propriedade.</span><span class="sxs-lookup"><span data-stu-id="72ba7-123">Since the navigation property is non-nullable, a required navigation is configured; and as long as the navigation is properly loaded, the dependent will be accessible via the property.</span></span> <span data-ttu-id="72ba7-124">No entanto, se a propriedade for acessada sem primeiro carregar adequadamente a entidade relacionada, um InvalidOperationException será gerado, pois o contrato de API foi usado incorretamente.</span><span class="sxs-lookup"><span data-stu-id="72ba7-124">If, however, the property is accessed without first properly loading the related entity, an InvalidOperationException is thrown, since the API contract has been used incorrectly.</span></span> <span data-ttu-id="72ba7-125">Observe que o EF deve ser configurado para sempre acessar o campo de backup e não a propriedade, pois depende de ser capaz de ler o valor mesmo quando não definido; consulte a [documentação sobre como fazer isso](xref:core/modeling/backing-field) , e considere especificar `PropertyAccessMode.Field` para verificar se a configuração está correta.</span><span class="sxs-lookup"><span data-stu-id="72ba7-125">Note that EF must be configured to always access the backing field and not the property, as it relies on being able to read the value even when unset; consult the documentation on [backing fields](xref:core/modeling/backing-field) on how to do this, and consider specifying `PropertyAccessMode.Field` to make sure the configuration is correct.</span></span>

<span data-ttu-id="72ba7-126">Como alternativa terser, é possível simplesmente inicializar a propriedade como NULL com a ajuda do operador NULL-tolerante (!):</span><span class="sxs-lookup"><span data-stu-id="72ba7-126">As a terser alternative, it is possible to simply initialize the property to null with the help of the null-forgiving operator (!):</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Order.cs?range=19)]

<span data-ttu-id="72ba7-127">Um valor nulo real nunca será observado, exceto como resultado de um bug de programação, por exemplo, acessar a propriedade de navegação sem carregar corretamente a entidade relacionada com antecedência.</span><span class="sxs-lookup"><span data-stu-id="72ba7-127">An actual null value will never be observed except as a result of a programming bug, e.g. accessing the navigation property without properly loading the related entity beforehand.</span></span>

> [!NOTE]
> <span data-ttu-id="72ba7-128">As navegações de coleção, que contêm referências a várias entidades relacionadas, sempre devem ser não anuláveis.</span><span class="sxs-lookup"><span data-stu-id="72ba7-128">Collection navigations, which contain references to multiple related entities, should always be non-nullable.</span></span> <span data-ttu-id="72ba7-129">Uma coleção vazia significa que não existe nenhuma entidade relacionada, mas a lista em si nunca deve ser nula.</span><span class="sxs-lookup"><span data-stu-id="72ba7-129">An empty collection means that no related entities exist, but the list itself should never be null.</span></span>

## <a name="navigating-and-including-nullable-relationships"></a><span data-ttu-id="72ba7-130">Navegando e incluindo relações anuláveis</span><span class="sxs-lookup"><span data-stu-id="72ba7-130">Navigating and including nullable relationships</span></span>

<span data-ttu-id="72ba7-131">Ao lidar com relações opcionais, é possível encontrar avisos do compilador em que uma exceção de referência nula real seria impossível.</span><span class="sxs-lookup"><span data-stu-id="72ba7-131">When dealing with optional relationships, it's possible to encounter compiler warnings where an actual null reference exception would be impossible.</span></span> <span data-ttu-id="72ba7-132">Ao traduzir e executar suas consultas LINQ, o EF Core garante que, se uma entidade relacionada opcional não existir, qualquer navegação nela será simplesmente ignorada, em vez de lançá-la.</span><span class="sxs-lookup"><span data-stu-id="72ba7-132">When translating and executing your LINQ queries, EF Core guarantees that if an optional related entity does not exist, any navigation to it will simply be ignored, rather than throwing.</span></span> <span data-ttu-id="72ba7-133">No entanto, o compilador não sabe disso EF Core garante e produz avisos como se a consulta LINQ fosse executada na memória, com LINQ to Objects.</span><span class="sxs-lookup"><span data-stu-id="72ba7-133">However, the compiler is unaware of this EF Core guarantee, and produces warnings as if the LINQ query were executed in memory, with LINQ to Objects.</span></span> <span data-ttu-id="72ba7-134">Como resultado, é necessário usar o operador NULL-tolerante (!) para informar ao compilador que um valor nulo real não é possível:</span><span class="sxs-lookup"><span data-stu-id="72ba7-134">As a result, it is necessary to use the null-forgiving operator (!) to inform the compiler that an actual null value isn't possible:</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Program.cs?range=46)]

<span data-ttu-id="72ba7-135">Um problema semelhante ocorre quando se inclui vários níveis de relações entre navegações opcionais:</span><span class="sxs-lookup"><span data-stu-id="72ba7-135">A similar issue occurs when including multiple levels of relationships across optional navigations:</span></span>

[!code-csharp[Main](../../../samples/core/Miscellaneous/NullableReferenceTypes/Program.cs?range=36-39&highlight=2)]

<span data-ttu-id="72ba7-136">Se você estiver fazendo isso muito, e os tipos de entidade em questão forem predominantemente (ou exclusivamente) usados em consultas EF Core, considere tornar as propriedades de navegação não anuláveis e configurá-las como opcionais por meio da API fluente ou das anotações de dados.</span><span class="sxs-lookup"><span data-stu-id="72ba7-136">If you find yourself doing this a lot, and the entity types in question are predominantly (or exclusively) used in EF Core queries, consider making the navigation properties non-nullable, and to configure them as optional via the Fluent API or Data Annotations.</span></span> <span data-ttu-id="72ba7-137">Isso removerá todos os avisos do compilador enquanto mantém a relação opcional; no entanto, se suas entidades forem atravessadas fora do EF Core, você poderá observar valores nulos, embora as propriedades sejam anotadas como não anuláveis.</span><span class="sxs-lookup"><span data-stu-id="72ba7-137">This will remove all compiler warnings while keeping the relationship optional; however, if your entities are traversed outside of EF Core, you may observe null values although the properties are annotated as non-nullable.</span></span>

## <a name="limitations"></a><span data-ttu-id="72ba7-138">Limitações</span><span class="sxs-lookup"><span data-stu-id="72ba7-138">Limitations</span></span>

* <span data-ttu-id="72ba7-139">A engenharia reversa atualmente não dá suporte C# [ C# a 8 tipos de referência anuláveis (NRTs)](/dotnet/csharp/tutorials/nullable-reference-types): EF Core sempre gera código que assume que o recurso está desativado.</span><span class="sxs-lookup"><span data-stu-id="72ba7-139">Reverse engineering does not currently support [C# 8 nullable reference types (NRTs)](/dotnet/csharp/tutorials/nullable-reference-types): EF Core always generates C# code that assumes the feature is off.</span></span> <span data-ttu-id="72ba7-140">Por exemplo, colunas de texto anuláveis serão com Scaffold como uma propriedade com o tipo `string`, não `string?`, com a API Fluent ou as anotações de dados usadas para configurar se uma propriedade é necessária ou não.</span><span class="sxs-lookup"><span data-stu-id="72ba7-140">For example, nullable text columns will be scaffolded as a property with type `string` , not `string?`, with either the Fluent API or Data Annotations used to configure whether a property is required or not.</span></span> <span data-ttu-id="72ba7-141">Você pode editar o código com Scaffold e substituí-los C# por anotações de nulidade.</span><span class="sxs-lookup"><span data-stu-id="72ba7-141">You can edit the scaffolded code and replace these with C# nullability annotations.</span></span> <span data-ttu-id="72ba7-142">O suporte do scaffolding para tipos de referência anuláveis é acompanhado pelo problema [#15520](https://github.com/aspnet/EntityFrameworkCore/issues/15520).</span><span class="sxs-lookup"><span data-stu-id="72ba7-142">Scaffolding support for nullable reference types is tracked by issue [#15520](https://github.com/aspnet/EntityFrameworkCore/issues/15520).</span></span>
* <span data-ttu-id="72ba7-143">A superfície da API pública do EF Core ainda não foi anotada quanto à nulidade (a API pública é "NULL-alheios"), o que, às vezes, é estranho usar quando o recurso NRT está ativado.</span><span class="sxs-lookup"><span data-stu-id="72ba7-143">EF Core's public API surface has not yet been annotated for nullability (the public API is "null-oblivious"), making it sometimes awkward to use when the NRT feature is turned on.</span></span> <span data-ttu-id="72ba7-144">Isso notavelmente inclui os operadores assíncronos LINQ expostos por EF Core, como [FirstOrDefaultAsync](/dotnet/api/microsoft.entityframeworkcore.entityframeworkqueryableextensions.firstordefaultasync#Microsoft_EntityFrameworkCore_EntityFrameworkQueryableExtensions_FirstOrDefaultAsync__1_System_Linq_IQueryable___0__System_Linq_Expressions_Expression_System_Func___0_System_Boolean___System_Threading_CancellationToken_).</span><span class="sxs-lookup"><span data-stu-id="72ba7-144">This notably includes the async LINQ operators exposed by EF Core, such as [FirstOrDefaultAsync](/dotnet/api/microsoft.entityframeworkcore.entityframeworkqueryableextensions.firstordefaultasync#Microsoft_EntityFrameworkCore_EntityFrameworkQueryableExtensions_FirstOrDefaultAsync__1_System_Linq_IQueryable___0__System_Linq_Expressions_Expression_System_Func___0_System_Boolean___System_Threading_CancellationToken_).</span></span> <span data-ttu-id="72ba7-145">Planejamos resolver isso para a versão 5,0.</span><span class="sxs-lookup"><span data-stu-id="72ba7-145">We plan to address this for the 5.0 release.</span></span>
