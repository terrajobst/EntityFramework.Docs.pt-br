---
title: Log e interceptação de operações de banco de dados-EF6
author: divega
ms.date: 10/23/2016
ms.assetid: b5ee7eb1-88cc-456e-b53c-c67e24c3f8ca
ms.openlocfilehash: 35b0284a5ad8b2b732f074589bd458d243312575
ms.sourcegitcommit: cc0ff36e46e9ed3527638f7208000e8521faef2e
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 03/06/2020
ms.locfileid: "78419474"
---
# <a name="logging-and-intercepting-database-operations"></a><span data-ttu-id="df7c8-102">Log e interceptação de operações de banco de dados</span><span class="sxs-lookup"><span data-stu-id="df7c8-102">Logging and intercepting database operations</span></span>
> [!NOTE]
> <span data-ttu-id="df7c8-103">**EF6 em diante apenas**: os recursos, as APIs etc. discutidos nessa página foram introduzidos no Entity Framework 6.</span><span class="sxs-lookup"><span data-stu-id="df7c8-103">**EF6 Onwards Only** - The features, APIs, etc. discussed in this page were introduced in Entity Framework 6.</span></span> <span data-ttu-id="df7c8-104">Se você estiver usando uma versão anterior, algumas ou todas as informações não se aplicarão.</span><span class="sxs-lookup"><span data-stu-id="df7c8-104">If you are using an earlier version, some or all of the information does not apply.</span></span>  

<span data-ttu-id="df7c8-105">A partir do Entity Framework 6, a qualquer momento Entity Framework envia um comando para o banco de dados esse comando pode ser interceptado pelo código do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="df7c8-105">Starting with Entity Framework 6, anytime Entity Framework sends a command to the database this command can be intercepted by application code.</span></span> <span data-ttu-id="df7c8-106">Isso é mais comumente usado para registrar em log o SQL, mas também pode ser usado para modificar ou anular o comando.</span><span class="sxs-lookup"><span data-stu-id="df7c8-106">This is most commonly used for logging SQL, but can also be used to modify or abort the command.</span></span>  

<span data-ttu-id="df7c8-107">Especificamente, o EF inclui:</span><span class="sxs-lookup"><span data-stu-id="df7c8-107">Specifically, EF includes:</span></span>  

- <span data-ttu-id="df7c8-108">Uma propriedade de log para o contexto semelhante a DataContext. log em LINQ to SQL</span><span class="sxs-lookup"><span data-stu-id="df7c8-108">A Log property for the context similar to DataContext.Log in LINQ to SQL</span></span>  
- <span data-ttu-id="df7c8-109">Um mecanismo para personalizar o conteúdo e a formatação da saída enviada ao log</span><span class="sxs-lookup"><span data-stu-id="df7c8-109">A mechanism to customize the content and formatting of the output sent to the log</span></span>  
- <span data-ttu-id="df7c8-110">Blocos de construção de baixo nível para interceptação, proporcionando maior controle/flexibilidade</span><span class="sxs-lookup"><span data-stu-id="df7c8-110">Low-level building blocks for interception giving greater control/flexibility</span></span>  

## <a name="context-log-property"></a><span data-ttu-id="df7c8-111">Propriedade de log de contexto</span><span class="sxs-lookup"><span data-stu-id="df7c8-111">Context Log property</span></span>  

<span data-ttu-id="df7c8-112">A propriedade DbContext. Database. log pode ser definida como um delegado para qualquer método que usa uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="df7c8-112">The DbContext.Database.Log property can be set to a delegate for any method that takes a string.</span></span> <span data-ttu-id="df7c8-113">Normalmente, ele é usado com qualquer TextWriter definindo-o como o método de "gravação" desse TextWriter.</span><span class="sxs-lookup"><span data-stu-id="df7c8-113">Most commonly it is used with any TextWriter by setting it to the “Write” method of that TextWriter.</span></span> <span data-ttu-id="df7c8-114">Todo o SQL gerado pelo contexto atual será registrado nesse gravador.</span><span class="sxs-lookup"><span data-stu-id="df7c8-114">All SQL generated by the current context will be logged to that writer.</span></span> <span data-ttu-id="df7c8-115">Por exemplo, o código a seguir irá registrar o SQL no console:</span><span class="sxs-lookup"><span data-stu-id="df7c8-115">For example, the following code will log SQL to the console:</span></span>  

``` csharp
using (var context = new BlogContext())
{
    context.Database.Log = Console.Write;

    // Your code here...
}
```  

<span data-ttu-id="df7c8-116">Observe que o contexto. Database. log está definido como console. Write.</span><span class="sxs-lookup"><span data-stu-id="df7c8-116">Notice that context.Database.Log is set to Console.Write.</span></span> <span data-ttu-id="df7c8-117">Isso é tudo o que é necessário para registrar o SQL no console.</span><span class="sxs-lookup"><span data-stu-id="df7c8-117">This is all that is needed to log SQL to the console.</span></span>  

<span data-ttu-id="df7c8-118">Vamos adicionar um código simples de consulta/inserção/atualização para que possamos ver alguma saída:</span><span class="sxs-lookup"><span data-stu-id="df7c8-118">Let’s add some simple query/insert/update code so that we can see some output:</span></span>  

``` csharp
using (var context = new BlogContext())
{
    context.Database.Log = Console.Write;

    var blog = context.Blogs.First(b => b.Title == "One Unicorn");

    blog.Posts.First().Title = "Green Eggs and Ham";

    blog.Posts.Add(new Post { Title = "I do not like them!" });

    context.SaveChangesAsync().Wait();
}
```  

<span data-ttu-id="df7c8-119">Isso irá gerar a seguinte saída:</span><span class="sxs-lookup"><span data-stu-id="df7c8-119">This will generate the following output:</span></span>  

``` SQL
SELECT TOP (1)
    [Extent1].[Id] AS [Id],
    [Extent1].[Title] AS [Title]
    FROM [dbo].[Blogs] AS [Extent1]
    WHERE (N'One Unicorn' = [Extent1].[Title]) AND ([Extent1].[Title] IS NOT NULL)
-- Executing at 10/8/2013 10:55:41 AM -07:00
-- Completed in 4 ms with result: SqlDataReader

SELECT
    [Extent1].[Id] AS [Id],
    [Extent1].[Title] AS [Title],
    [Extent1].[BlogId] AS [BlogId]
    FROM [dbo].[Posts] AS [Extent1]
    WHERE [Extent1].[BlogId] = @EntityKeyValue1
-- EntityKeyValue1: '1' (Type = Int32)
-- Executing at 10/8/2013 10:55:41 AM -07:00
-- Completed in 2 ms with result: SqlDataReader

UPDATE [dbo].[Posts]
SET [Title] = @0
WHERE ([Id] = @1)
-- @0: 'Green Eggs and Ham' (Type = String, Size = -1)
-- @1: '1' (Type = Int32)
-- Executing asynchronously at 10/8/2013 10:55:41 AM -07:00
-- Completed in 12 ms with result: 1

INSERT [dbo].[Posts]([Title], [BlogId])
VALUES (@0, @1)
SELECT [Id]
FROM [dbo].[Posts]
WHERE @@ROWCOUNT > 0 AND [Id] = scope_identity()
-- @0: 'I do not like them!' (Type = String, Size = -1)
-- @1: '1' (Type = Int32)
-- Executing asynchronously at 10/8/2013 10:55:41 AM -07:00
-- Completed in 2 ms with result: SqlDataReader
```  

<span data-ttu-id="df7c8-120">(Observe que essa é a saída supondo que qualquer inicialização de banco de dados já tenha ocorrido.</span><span class="sxs-lookup"><span data-stu-id="df7c8-120">(Note that this is the output assuming any database initialization has already happened.</span></span> <span data-ttu-id="df7c8-121">Se a inicialização do banco de dados ainda não tiver acontecido, haveria muito mais saída mostrando que todas as migrações de trabalho faz isso nos bastidores para verificar ou criar um novo banco de dados.)</span><span class="sxs-lookup"><span data-stu-id="df7c8-121">If database initialization had not already happened then there would be a lot more output showing all the work Migrations does under the covers to check for or create a new database.)</span></span>  

## <a name="what-gets-logged"></a><span data-ttu-id="df7c8-122">O que é registrado em log?</span><span class="sxs-lookup"><span data-stu-id="df7c8-122">What gets logged?</span></span>  

<span data-ttu-id="df7c8-123">Quando a propriedade log for definida, todos os itens a seguir serão registrados em log:</span><span class="sxs-lookup"><span data-stu-id="df7c8-123">When the Log property is set all of the following will be logged:</span></span>  

- <span data-ttu-id="df7c8-124">SQL para todos os diferentes tipos de comandos.</span><span class="sxs-lookup"><span data-stu-id="df7c8-124">SQL for all different kinds of commands.</span></span> <span data-ttu-id="df7c8-125">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="df7c8-125">For example:</span></span>  
    - <span data-ttu-id="df7c8-126">Consultas, incluindo consultas comuns do LINQ, consultas do eSQL e consultas brutas de métodos como SQLQuery</span><span class="sxs-lookup"><span data-stu-id="df7c8-126">Queries, including normal LINQ queries, eSQL queries, and raw queries from methods such as SqlQuery</span></span>  
    - <span data-ttu-id="df7c8-127">Inserções, atualizações e exclusões geradas como parte do SaveChanges</span><span class="sxs-lookup"><span data-stu-id="df7c8-127">Inserts, updates, and deletes generated as part of SaveChanges</span></span>  
    - <span data-ttu-id="df7c8-128">Relações de carregamento de relacionamento como aquelas geradas pelo carregamento lento</span><span class="sxs-lookup"><span data-stu-id="df7c8-128">Relationship loading queries such as those generated by lazy loading</span></span>  
- <span data-ttu-id="df7c8-129">parâmetros</span><span class="sxs-lookup"><span data-stu-id="df7c8-129">Parameters</span></span>  
- <span data-ttu-id="df7c8-130">Se o comando está sendo executado de forma assíncrona</span><span class="sxs-lookup"><span data-stu-id="df7c8-130">Whether or not the command is being executed asynchronously</span></span>  
- <span data-ttu-id="df7c8-131">Um carimbo de data/hora que indica quando o comando iniciou a execução</span><span class="sxs-lookup"><span data-stu-id="df7c8-131">A timestamp indicating when the command started executing</span></span>  
- <span data-ttu-id="df7c8-132">Se o comando foi concluído com êxito, se houve falha ao lançar uma exceção ou, para Async, foi cancelado</span><span class="sxs-lookup"><span data-stu-id="df7c8-132">Whether or not the command completed successfully, failed by throwing an exception, or, for async, was canceled</span></span>  
- <span data-ttu-id="df7c8-133">Alguma indicação do valor de resultado</span><span class="sxs-lookup"><span data-stu-id="df7c8-133">Some indication of the result value</span></span>  
- <span data-ttu-id="df7c8-134">A quantidade aproximada de tempo necessário para executar o comando.</span><span class="sxs-lookup"><span data-stu-id="df7c8-134">The approximate amount of time it took to execute the command.</span></span> <span data-ttu-id="df7c8-135">Observe que essa é a hora de enviar o comando para obter o objeto de resultado de volta.</span><span class="sxs-lookup"><span data-stu-id="df7c8-135">Note that this is the time from sending the command to getting the result object back.</span></span> <span data-ttu-id="df7c8-136">Ele não inclui tempo para ler os resultados.</span><span class="sxs-lookup"><span data-stu-id="df7c8-136">It does not include time to read the results.</span></span>  

<span data-ttu-id="df7c8-137">Observando a saída de exemplo acima, cada um dos quatro comandos registrados é:</span><span class="sxs-lookup"><span data-stu-id="df7c8-137">Looking at the example output above, each of the four commands logged are:</span></span>  

- <span data-ttu-id="df7c8-138">A consulta resultante da chamada ao contexto. Blogs. primeiro</span><span class="sxs-lookup"><span data-stu-id="df7c8-138">The query resulting from the call to context.Blogs.First</span></span>  
    - <span data-ttu-id="df7c8-139">Observe que o método ToString de obter o SQL não teria trabalhado para essa consulta, pois "First" não fornece um IQueryable no qual ToString poderia ser chamado</span><span class="sxs-lookup"><span data-stu-id="df7c8-139">Notice that the ToString method of getting the SQL would not have worked for this query since “First” does not provide an IQueryable on which ToString could be called</span></span>  
- <span data-ttu-id="df7c8-140">A consulta resultante do carregamento lento do blog. Postagens</span><span class="sxs-lookup"><span data-stu-id="df7c8-140">The query resulting from the lazy-loading of blog.Posts</span></span>  
    - <span data-ttu-id="df7c8-141">Observe os detalhes do parâmetro para o valor de chave para o qual o carregamento lento está ocorrendo</span><span class="sxs-lookup"><span data-stu-id="df7c8-141">Notice the parameter details for the key value for which lazy loading is happening</span></span>  
    - <span data-ttu-id="df7c8-142">Somente as propriedades do parâmetro que são definidas como valores não padrão são registradas em log.</span><span class="sxs-lookup"><span data-stu-id="df7c8-142">Only properties of the parameter that are set to non-default values are logged.</span></span> <span data-ttu-id="df7c8-143">Por exemplo, a propriedade Size só será mostrada se for diferente de zero.</span><span class="sxs-lookup"><span data-stu-id="df7c8-143">For example, the Size property is only shown if it is non-zero.</span></span>  
- <span data-ttu-id="df7c8-144">Dois comandos resultantes de SaveChangesAsync; um para a atualização alterar um título de postagem, o outro para uma inserção para adicionar uma nova postagem</span><span class="sxs-lookup"><span data-stu-id="df7c8-144">Two commands resulting from SaveChangesAsync; one for the update to change a post title, the other for an insert to add a new post</span></span>  
    - <span data-ttu-id="df7c8-145">Observe os detalhes do parâmetro para as propriedades FK e title</span><span class="sxs-lookup"><span data-stu-id="df7c8-145">Notice the parameter details for the FK and Title properties</span></span>  
    - <span data-ttu-id="df7c8-146">Observe que esses comandos estão sendo executados de forma assíncrona</span><span class="sxs-lookup"><span data-stu-id="df7c8-146">Notice that these commands are being executed asynchronously</span></span>  

## <a name="logging-to-different-places"></a><span data-ttu-id="df7c8-147">Registro em locais diferentes</span><span class="sxs-lookup"><span data-stu-id="df7c8-147">Logging to different places</span></span>  

<span data-ttu-id="df7c8-148">Como mostrado acima, o registro em log no console é muito fácil.</span><span class="sxs-lookup"><span data-stu-id="df7c8-148">As shown above logging to the console is super easy.</span></span> <span data-ttu-id="df7c8-149">Também é fácil fazer logon na memória, no arquivo, etc. usando diferentes tipos de [TextWriter](https://msdn.microsoft.com/library/system.io.textwriter.aspx).</span><span class="sxs-lookup"><span data-stu-id="df7c8-149">It’s also easy to log to memory, file, etc. by using different kinds of [TextWriter](https://msdn.microsoft.com/library/system.io.textwriter.aspx).</span></span>  

<span data-ttu-id="df7c8-150">Se você estiver familiarizado com LINQ to SQL pode observar que, em LINQ to SQL a propriedade log é definida como o objeto TextWriter real (por exemplo, console. out) enquanto estiver no EF, a propriedade log é definida como um método que aceita uma cadeia de caracteres (por exemplo, , Console. Write ou console. out. Write).</span><span class="sxs-lookup"><span data-stu-id="df7c8-150">If you are familiar with LINQ to SQL you might notice that in LINQ to SQL the Log property is set to the actual TextWriter object (for example, Console.Out) while in EF the Log property is set to a method that accepts a string (for example, Console.Write or Console.Out.Write).</span></span> <span data-ttu-id="df7c8-151">O motivo disso é desacoplar o EF do TextWriter aceitando qualquer delegado que possa atuar como um coletor de cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="df7c8-151">The reason for this is to decouple EF from TextWriter by accepting any delegate that can act as a sink for strings.</span></span> <span data-ttu-id="df7c8-152">Por exemplo, imagine que você já tem alguma estrutura de registro em log e define um método de log como este:</span><span class="sxs-lookup"><span data-stu-id="df7c8-152">For example, imagine that you already have some logging framework and it defines a logging method like so:</span></span>  

``` csharp
public class MyLogger
{
    public void Log(string component, string message)
    {
        Console.WriteLine("Component: {0} Message: {1} ", component, message);
    }
}
```  

<span data-ttu-id="df7c8-153">Isso pode ser conectado à propriedade log do EF da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="df7c8-153">This could be hooked up to the EF Log property like this:</span></span>  

``` csharp
var logger = new MyLogger();
context.Database.Log = s => logger.Log("EFApp", s);
```  

## <a name="result-logging"></a><span data-ttu-id="df7c8-154">Log de resultados</span><span class="sxs-lookup"><span data-stu-id="df7c8-154">Result logging</span></span>  

<span data-ttu-id="df7c8-155">O agente de log padrão registra o texto do comando (SQL), os parâmetros e a linha "executando" com um carimbo de data/hora antes de o comando ser enviado ao banco de dados.</span><span class="sxs-lookup"><span data-stu-id="df7c8-155">The default logger logs command text (SQL), parameters, and the “Executing” line with a timestamp before the command is sent to the database.</span></span> <span data-ttu-id="df7c8-156">Uma linha "concluída" contendo tempo decorrido é registrada após a execução do comando.</span><span class="sxs-lookup"><span data-stu-id="df7c8-156">A “completed” line containing elapsed time is logged following execution of the command.</span></span>  

<span data-ttu-id="df7c8-157">Observe que, para comandos assíncronos, a linha "concluída" não é registrada até que a tarefa assíncrona seja realmente concluída, falhe ou seja cancelada.</span><span class="sxs-lookup"><span data-stu-id="df7c8-157">Note that for async commands the “completed” line is not logged until the async task actually completes, fails, or is canceled.</span></span>  

<span data-ttu-id="df7c8-158">A linha "concluída" contém informações diferentes dependendo do tipo de comando e se a execução foi ou não bem-sucedida.</span><span class="sxs-lookup"><span data-stu-id="df7c8-158">The “completed” line contains different information depending on the type of command and whether or not execution was successful.</span></span>  

### <a name="successful-execution"></a><span data-ttu-id="df7c8-159">Execução bem-sucedida</span><span class="sxs-lookup"><span data-stu-id="df7c8-159">Successful execution</span></span>  

<span data-ttu-id="df7c8-160">Para comandos que são concluídos com êxito a saída é "concluído em x ms com resultado:" seguido por alguma indicação do que é o resultado.</span><span class="sxs-lookup"><span data-stu-id="df7c8-160">For commands that complete successfully the output is “Completed in x ms with result: “ followed by some indication of what the result was.</span></span> <span data-ttu-id="df7c8-161">Para comandos que retornam um leitor de dados, a indicação de resultado é o tipo de [DbDataReader](https://msdn.microsoft.com/library/system.data.common.dbdatareader.aspx) retornado.</span><span class="sxs-lookup"><span data-stu-id="df7c8-161">For commands that return a data reader the result indication is the type of [DbDataReader](https://msdn.microsoft.com/library/system.data.common.dbdatareader.aspx) returned.</span></span> <span data-ttu-id="df7c8-162">Para comandos que retornam um valor inteiro, como o comando Update mostrado acima, o resultado mostrado é o inteiro.</span><span class="sxs-lookup"><span data-stu-id="df7c8-162">For commands that return an integer value such as the update command shown above the result shown is that integer.</span></span>  

### <a name="failed-execution"></a><span data-ttu-id="df7c8-163">Falha na execução</span><span class="sxs-lookup"><span data-stu-id="df7c8-163">Failed execution</span></span>  

<span data-ttu-id="df7c8-164">Para comandos que falham lançando uma exceção, a saída contém a mensagem da exceção.</span><span class="sxs-lookup"><span data-stu-id="df7c8-164">For commands that fail by throwing an exception, the output contains the message from the exception.</span></span> <span data-ttu-id="df7c8-165">Por exemplo, usar SQLQuery para consultar uma tabela que exista resultará na saída do log, algo assim:</span><span class="sxs-lookup"><span data-stu-id="df7c8-165">For example, using SqlQuery to query against a table that does exist will result in log output something like this:</span></span>  

``` SQL
SELECT * from ThisTableIsMissing
-- Executing at 5/13/2013 10:19:05 AM
-- Failed in 1 ms with error: Invalid object name 'ThisTableIsMissing'.
```  

### <a name="canceled-execution"></a><span data-ttu-id="df7c8-166">Execução cancelada</span><span class="sxs-lookup"><span data-stu-id="df7c8-166">Canceled execution</span></span>  

<span data-ttu-id="df7c8-167">Para comandos assíncronos em que a tarefa é cancelada, o resultado pode ser uma falha com uma exceção, pois isso é o que o provedor ADO.NET subjacente geralmente faz quando é feita uma tentativa de cancelamento.</span><span class="sxs-lookup"><span data-stu-id="df7c8-167">For async commands where the task is canceled the result could be failure with an exception, since this is what the underlying ADO.NET provider often does when an attempt is made to cancel.</span></span> <span data-ttu-id="df7c8-168">Se isso não acontecer e a tarefa for cancelada corretamente, a saída terá uma aparência semelhante a esta:</span><span class="sxs-lookup"><span data-stu-id="df7c8-168">If this doesn’t happen and the task is canceled cleanly then the output will look something like this:</span></span>  

```console
update Blogs set Title = 'No' where Id = -1
-- Executing asynchronously at 5/13/2013 10:21:10 AM
-- Canceled in 1 ms
```  

## <a name="changing-log-content-and-formatting"></a><span data-ttu-id="df7c8-169">Alterando o conteúdo e a formatação do log</span><span class="sxs-lookup"><span data-stu-id="df7c8-169">Changing log content and formatting</span></span>  

<span data-ttu-id="df7c8-170">Nos bastidores, a Propriedade Database. log usa um objeto DatabaseLogFormatter.</span><span class="sxs-lookup"><span data-stu-id="df7c8-170">Under the covers the Database.Log property makes use of a DatabaseLogFormatter object.</span></span> <span data-ttu-id="df7c8-171">Esse objeto associa efetivamente uma implementação de IDbCommandInterceptor (veja abaixo) a um delegado que aceita cadeias de caracteres e um DbContext.</span><span class="sxs-lookup"><span data-stu-id="df7c8-171">This object effectively binds an IDbCommandInterceptor implementation (see below) to a delegate that accepts strings and a DbContext.</span></span> <span data-ttu-id="df7c8-172">Isso significa que os métodos em DatabaseLogFormatter são chamados antes e depois da execução de comandos pelo EF.</span><span class="sxs-lookup"><span data-stu-id="df7c8-172">This means that methods on DatabaseLogFormatter are called before and after the execution of commands by EF.</span></span> <span data-ttu-id="df7c8-173">Esses métodos DatabaseLogFormatter reúnem e formatam a saída de log e a enviam para o delegado.</span><span class="sxs-lookup"><span data-stu-id="df7c8-173">These DatabaseLogFormatter methods gather and format log output and send it to the delegate.</span></span>  

### <a name="customizing-databaselogformatter"></a><span data-ttu-id="df7c8-174">Personalizando o DatabaseLogFormatter</span><span class="sxs-lookup"><span data-stu-id="df7c8-174">Customizing DatabaseLogFormatter</span></span>  

<span data-ttu-id="df7c8-175">Alterar o que é registrado em log e como ele é formatado pode ser obtido criando uma nova classe que deriva de DatabaseLogFormatter e substitui métodos conforme apropriado.</span><span class="sxs-lookup"><span data-stu-id="df7c8-175">Changing what is logged and how it is formatted can be achieved by creating a new class that derives from DatabaseLogFormatter and overrides methods as appropriate.</span></span> <span data-ttu-id="df7c8-176">Os métodos mais comuns a serem substituídos são:</span><span class="sxs-lookup"><span data-stu-id="df7c8-176">The most common methods to override are:</span></span>  

- <span data-ttu-id="df7c8-177">LogCommand – substitua isso para alterar como os comandos são registrados antes de serem executados.</span><span class="sxs-lookup"><span data-stu-id="df7c8-177">LogCommand – Override this to change how commands are logged before they are executed.</span></span> <span data-ttu-id="df7c8-178">Por padrão, o LogCommand chama LogParameter para cada parâmetro; Você pode optar por fazer o mesmo em sua substituição ou manipular parâmetros de maneira diferente em vez disso.</span><span class="sxs-lookup"><span data-stu-id="df7c8-178">By default LogCommand calls LogParameter for each parameter; you may choose to do the same in your override or handle parameters differently instead.</span></span>  
- <span data-ttu-id="df7c8-179">LogResult – substitua isso para alterar a forma como o resultado da execução de um comando é registrado.</span><span class="sxs-lookup"><span data-stu-id="df7c8-179">LogResult – Override this to change how the outcome from executing a command is logged.</span></span>  
- <span data-ttu-id="df7c8-180">LogParameter – substitua isso para alterar a formatação e o conteúdo do log de parâmetros.</span><span class="sxs-lookup"><span data-stu-id="df7c8-180">LogParameter – Override this to change the formatting and content of parameter logging.</span></span>  

<span data-ttu-id="df7c8-181">Por exemplo, suponha que queríamos registrar apenas uma única linha antes de cada comando ser enviado ao banco de dados.</span><span class="sxs-lookup"><span data-stu-id="df7c8-181">For example, suppose we wanted to log just a single line before each command is sent to the database.</span></span> <span data-ttu-id="df7c8-182">Isso pode ser feito com duas substituições:</span><span class="sxs-lookup"><span data-stu-id="df7c8-182">This can be done with two overrides:</span></span>  

- <span data-ttu-id="df7c8-183">Substituir LogCommand para formatar e gravar a única linha de SQL</span><span class="sxs-lookup"><span data-stu-id="df7c8-183">Override LogCommand to format and write the single line of SQL</span></span>  
- <span data-ttu-id="df7c8-184">Substitua LogResult para não fazer nada.</span><span class="sxs-lookup"><span data-stu-id="df7c8-184">Override LogResult to do nothing.</span></span>  

<span data-ttu-id="df7c8-185">O código seria semelhante a este:</span><span class="sxs-lookup"><span data-stu-id="df7c8-185">The code would look something like this:</span></span>

``` csharp
public class OneLineFormatter : DatabaseLogFormatter
{
    public OneLineFormatter(DbContext context, Action<string> writeAction)
        : base(context, writeAction)
    {
    }

    public override void LogCommand<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        Write(string.Format(
            "Context '{0}' is executing command '{1}'{2}",
            Context.GetType().Name,
            command.CommandText.Replace(Environment.NewLine, ""),
            Environment.NewLine));
    }

    public override void LogResult<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
    }
}
```  

<span data-ttu-id="df7c8-186">Para a saída de log, basta chamar o método Write que enviará a saída para o delegado de gravação configurado.</span><span class="sxs-lookup"><span data-stu-id="df7c8-186">To log output simply call the Write method which will send output to the configured write delegate.</span></span>  

<span data-ttu-id="df7c8-187">(Observe que esse código faz uma remoção simplista de quebras de linha, apenas como um exemplo.</span><span class="sxs-lookup"><span data-stu-id="df7c8-187">(Note that this code does simplistic removal of line breaks just as an example.</span></span> <span data-ttu-id="df7c8-188">Provavelmente, não funcionará bem para exibir SQL complexo.)</span><span class="sxs-lookup"><span data-stu-id="df7c8-188">It will likely not work well for viewing complex SQL.)</span></span>  

### <a name="setting-the-databaselogformatter"></a><span data-ttu-id="df7c8-189">Configurando o DatabaseLogFormatter</span><span class="sxs-lookup"><span data-stu-id="df7c8-189">Setting the DatabaseLogFormatter</span></span>  

<span data-ttu-id="df7c8-190">Depois que uma nova classe DatabaseLogFormatter tiver sido criada, precisará ser registrada com o EF.</span><span class="sxs-lookup"><span data-stu-id="df7c8-190">Once a new DatabaseLogFormatter class has been created it needs to be registered with EF.</span></span> <span data-ttu-id="df7c8-191">Isso é feito usando a configuração baseada em código.</span><span class="sxs-lookup"><span data-stu-id="df7c8-191">This is done using code-based configuration.</span></span> <span data-ttu-id="df7c8-192">Resumindo, isso significa criar uma nova classe que deriva de DbConfiguration no mesmo assembly que a classe DbContext e, em seguida, chamando SetDatabaseLogFormatter no construtor dessa nova classe.</span><span class="sxs-lookup"><span data-stu-id="df7c8-192">In a nutshell this means creating a new class that derives from DbConfiguration in the same assembly as your DbContext class and then calling SetDatabaseLogFormatter in the constructor of this new class.</span></span> <span data-ttu-id="df7c8-193">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="df7c8-193">For example:</span></span>  

``` csharp
public class MyDbConfiguration : DbConfiguration
{
    public MyDbConfiguration()
    {
        SetDatabaseLogFormatter(
            (context, writeAction) => new OneLineFormatter(context, writeAction));
    }
}
```  

### <a name="using-the-new-databaselogformatter"></a><span data-ttu-id="df7c8-194">Usando o novo DatabaseLogFormatter</span><span class="sxs-lookup"><span data-stu-id="df7c8-194">Using the new DatabaseLogFormatter</span></span>  

<span data-ttu-id="df7c8-195">Esse novo DatabaseLogFormatter agora será usado sempre que Database. log for definido.</span><span class="sxs-lookup"><span data-stu-id="df7c8-195">This new DatabaseLogFormatter will now be used anytime Database.Log is set.</span></span> <span data-ttu-id="df7c8-196">Assim, executar o código da parte 1 agora resultará na seguinte saída:</span><span class="sxs-lookup"><span data-stu-id="df7c8-196">So, running the code from part 1 will now result in the following output:</span></span>  

```console
Context 'BlogContext' is executing command 'SELECT TOP (1) [Extent1].[Id] AS [Id], [Extent1].[Title] AS [Title]FROM [dbo].[Blogs] AS [Extent1]WHERE (N'One Unicorn' = [Extent1].[Title]) AND ([Extent1].[Title] IS NOT NULL)'
Context 'BlogContext' is executing command 'SELECT [Extent1].[Id] AS [Id], [Extent1].[Title] AS [Title], [Extent1].[BlogId] AS [BlogId]FROM [dbo].[Posts] AS [Extent1]WHERE [Extent1].[BlogId] = @EntityKeyValue1'
Context 'BlogContext' is executing command 'update [dbo].[Posts]set [Title] = @0where ([Id] = @1)'
Context 'BlogContext' is executing command 'insert [dbo].[Posts]([Title], [BlogId])values (@0, @1)select [Id]from [dbo].[Posts]where @@rowcount > 0 and [Id] = scope_identity()'
```  

## <a name="interception-building-blocks"></a><span data-ttu-id="df7c8-197">Blocos de construção de interceptação</span><span class="sxs-lookup"><span data-stu-id="df7c8-197">Interception building blocks</span></span>  

<span data-ttu-id="df7c8-198">Até aqui, vimos como usar DbContext. Database. log para registrar em log o SQL gerado pelo EF.</span><span class="sxs-lookup"><span data-stu-id="df7c8-198">So far we have looked at how to use DbContext.Database.Log to log the SQL generated by EF.</span></span> <span data-ttu-id="df7c8-199">Mas esse código é, na verdade, uma fachada relativamente fina em alguns blocos de construção de baixo nível para uma interceptação mais geral.</span><span class="sxs-lookup"><span data-stu-id="df7c8-199">But this code is actually a relatively thin facade over some low-level building blocks for more general interception.</span></span>  

### <a name="interception-interfaces"></a><span data-ttu-id="df7c8-200">Interfaces de interceptação</span><span class="sxs-lookup"><span data-stu-id="df7c8-200">Interception interfaces</span></span>  

<span data-ttu-id="df7c8-201">O código de interceptação é criado em relação ao conceito de interfaces de interceptação.</span><span class="sxs-lookup"><span data-stu-id="df7c8-201">The interception code is built around the concept of interception interfaces.</span></span> <span data-ttu-id="df7c8-202">Essas interfaces herdam de IDbInterceptor e definem métodos que são chamados quando o EF executa alguma ação.</span><span class="sxs-lookup"><span data-stu-id="df7c8-202">These interfaces inherit from IDbInterceptor and define methods that are called when EF performs some action.</span></span> <span data-ttu-id="df7c8-203">A intenção é ter uma interface por tipo de objeto que está sendo interceptado.</span><span class="sxs-lookup"><span data-stu-id="df7c8-203">The intent is to have one interface per type of object being intercepted.</span></span> <span data-ttu-id="df7c8-204">Por exemplo, a interface IDbCommandInterceptor define métodos que são chamados antes do EF fazer uma chamada para ExecuteNonQuery, ExecuteScalar, ExecuteReader e métodos relacionados.</span><span class="sxs-lookup"><span data-stu-id="df7c8-204">For example, the IDbCommandInterceptor interface defines methods that are called before EF makes a call to ExecuteNonQuery, ExecuteScalar, ExecuteReader, and related methods.</span></span> <span data-ttu-id="df7c8-205">Da mesma forma, a interface define os métodos que são chamados quando cada uma dessas operações é concluída.</span><span class="sxs-lookup"><span data-stu-id="df7c8-205">Likewise, the interface defines methods that are called when each of these operations completes.</span></span> <span data-ttu-id="df7c8-206">A classe DatabaseLogFormatter que vimos acima implementa essa interface para fazer log de comandos.</span><span class="sxs-lookup"><span data-stu-id="df7c8-206">The DatabaseLogFormatter class that we looked at above implements this interface to log commands.</span></span>  

### <a name="the-interception-context"></a><span data-ttu-id="df7c8-207">O contexto de interceptação</span><span class="sxs-lookup"><span data-stu-id="df7c8-207">The interception context</span></span>  

<span data-ttu-id="df7c8-208">Observando os métodos definidos em qualquer uma das interfaces do Interceptor, é aparente que cada chamada recebe um objeto do tipo DbInterceptionContext ou algum tipo derivado dele, como DbCommandInterceptionContext\<\>.</span><span class="sxs-lookup"><span data-stu-id="df7c8-208">Looking at the methods defined on any of the interceptor interfaces it is apparent that every call is given an object of type DbInterceptionContext or some type derived from this such as DbCommandInterceptionContext\<\>.</span></span> <span data-ttu-id="df7c8-209">Este objeto contém informações contextuais sobre a ação que o EF está assumindo.</span><span class="sxs-lookup"><span data-stu-id="df7c8-209">This object contains contextual information about the action that EF is taking.</span></span> <span data-ttu-id="df7c8-210">Por exemplo, se a ação estiver sendo executada em nome de um DbContext, o DbContext será incluído no DbInterceptionContext.</span><span class="sxs-lookup"><span data-stu-id="df7c8-210">For example, if the action is being taken on behalf of a DbContext, then the DbContext is included in the DbInterceptionContext.</span></span> <span data-ttu-id="df7c8-211">Da mesma forma, para comandos que estão sendo executados de forma assíncrona, o sinalizador IsAsync é definido em DbCommandInterceptionContext.</span><span class="sxs-lookup"><span data-stu-id="df7c8-211">Similarly, for commands that are being executed asynchronously, the IsAsync flag is set on DbCommandInterceptionContext.</span></span>  

### <a name="result-handling"></a><span data-ttu-id="df7c8-212">Manipulação de resultados</span><span class="sxs-lookup"><span data-stu-id="df7c8-212">Result handling</span></span>  

<span data-ttu-id="df7c8-213">A classe DbCommandInterceptionContext\<\> contém uma propriedade chamada Result, OriginalResult, Exception e OriginalException.</span><span class="sxs-lookup"><span data-stu-id="df7c8-213">The DbCommandInterceptionContext\<\> class contains a properties called Result, OriginalResult, Exception, and OriginalException.</span></span> <span data-ttu-id="df7c8-214">Essas propriedades são definidas como NULL/zero para chamadas para os métodos de interceptação que são chamados antes da execução da operação — ou seja, para o... Executando métodos.</span><span class="sxs-lookup"><span data-stu-id="df7c8-214">These properties are set to null/zero for calls to the interception methods that are called before the operation is executed — that is, for the …Executing methods.</span></span> <span data-ttu-id="df7c8-215">Se a operação for executada e tiver sucesso, Result e OriginalResult serão definidos como o resultado da operação.</span><span class="sxs-lookup"><span data-stu-id="df7c8-215">If the operation is executed and succeeds, then Result and OriginalResult are set to the result of the operation.</span></span> <span data-ttu-id="df7c8-216">Esses valores podem ser observados nos métodos de interceptação que são chamados depois que a operação é executada — ou seja, no... Métodos executados.</span><span class="sxs-lookup"><span data-stu-id="df7c8-216">These values can then be observed in the interception methods that are called after the operation has executed — that is, on the …Executed methods.</span></span> <span data-ttu-id="df7c8-217">Da mesma forma, se a operação for lançada, a exceção e as propriedades OriginalException serão definidas.</span><span class="sxs-lookup"><span data-stu-id="df7c8-217">Likewise, if the operation throws, then the Exception and OriginalException properties will be set.</span></span>  

#### <a name="suppressing-execution"></a><span data-ttu-id="df7c8-218">Suprimindo a execução</span><span class="sxs-lookup"><span data-stu-id="df7c8-218">Suppressing execution</span></span>  

<span data-ttu-id="df7c8-219">Se um interceptor definir a propriedade Result antes da execução do comando (em um dos... Executando métodos) em seguida, o EF não tentará executar o comando de fato, mas, em vez disso, usará apenas o conjunto de resultados.</span><span class="sxs-lookup"><span data-stu-id="df7c8-219">If an interceptor sets the Result property before the command has executed (in one of the …Executing methods) then EF will not attempt to actually execute the command, but will instead just use the result set.</span></span> <span data-ttu-id="df7c8-220">Em outras palavras, o interceptador pode suprimir a execução do comando, mas tem o EF continuar como se o comando tivesse sido executado.</span><span class="sxs-lookup"><span data-stu-id="df7c8-220">In other words, the interceptor can suppress execution of the command but have EF continue as if the command had been executed.</span></span>  

<span data-ttu-id="df7c8-221">Um exemplo de como isso pode ser usado é o comando em lotes que tradicionalmente foi feito com um provedor de encapsulamento.</span><span class="sxs-lookup"><span data-stu-id="df7c8-221">An example of how this might be used is the command batching that has traditionally been done with a wrapping provider.</span></span> <span data-ttu-id="df7c8-222">O Interceptor armazenaria o comando para execução posterior como um lote, mas "fingir" para o EF que o comando executou normalmente.</span><span class="sxs-lookup"><span data-stu-id="df7c8-222">The interceptor would store the command for later execution as a batch but would “pretend” to EF that the command had executed as normal.</span></span> <span data-ttu-id="df7c8-223">Observe que ele requer mais do que isso para implementar o envio em lote, mas este é um exemplo de como a alteração do resultado da interceptação pode ser usada.</span><span class="sxs-lookup"><span data-stu-id="df7c8-223">Note that it requires more than this to implement batching, but this is an example of how changing the interception result might be used.</span></span>  

<span data-ttu-id="df7c8-224">A execução também pode ser suprimida com a definição da propriedade Exception em um dos... Executando métodos.</span><span class="sxs-lookup"><span data-stu-id="df7c8-224">Execution can also be suppressed by setting the Exception property in one of the …Executing methods.</span></span> <span data-ttu-id="df7c8-225">Isso faz com que o EF continue como se a execução da operação tivesse falhado lançando a exceção fornecida.</span><span class="sxs-lookup"><span data-stu-id="df7c8-225">This causes EF to continue as if execution of the operation had failed by throwing the given exception.</span></span> <span data-ttu-id="df7c8-226">Isso pode, naturalmente, fazer com que o aplicativo falhe, mas também pode ser uma exceção transitória ou alguma outra exceção que seja tratada pelo EF.</span><span class="sxs-lookup"><span data-stu-id="df7c8-226">This may, of course, cause the application to crash, but it may also be a transient exception or some other exception that is handled by EF.</span></span> <span data-ttu-id="df7c8-227">Por exemplo, isso pode ser usado em ambientes de teste para testar o comportamento de um aplicativo quando a execução do comando falha.</span><span class="sxs-lookup"><span data-stu-id="df7c8-227">For example, this could be used in test environments to test the behavior of an application when command execution fails.</span></span>  

#### <a name="changing-the-result-after-execution"></a><span data-ttu-id="df7c8-228">Alterando o resultado após a execução</span><span class="sxs-lookup"><span data-stu-id="df7c8-228">Changing the result after execution</span></span>  

<span data-ttu-id="df7c8-229">Se um interceptor definir a propriedade Result depois que o comando for executado (em um dos... Métodos executados), o EF usará o resultado alterado em vez do resultado que foi realmente retornado da operação.</span><span class="sxs-lookup"><span data-stu-id="df7c8-229">If an interceptor sets the Result property after the command has executed (in one of the …Executed methods) then EF will use the changed result instead of the result that was actually returned from the operation.</span></span> <span data-ttu-id="df7c8-230">Da mesma forma, se um interceptor definir a propriedade Exception depois que o comando for executado, o EF gerará a exceção Set como se a operação tivesse gerado a exceção.</span><span class="sxs-lookup"><span data-stu-id="df7c8-230">Similarly, if an interceptor sets the Exception property after the command has executed, then EF will throw the set exception as if the operation had thrown the exception.</span></span>  

<span data-ttu-id="df7c8-231">Um interceptor também pode definir a propriedade Exception como NULL para indicar que nenhuma exceção deve ser lançada.</span><span class="sxs-lookup"><span data-stu-id="df7c8-231">An interceptor can also set the Exception property to null to indicate that no exception should be thrown.</span></span> <span data-ttu-id="df7c8-232">Isso pode ser útil se a execução da operação falhar, mas o Interceptor desejar que o EF continue como se a operação tivesse sido bem-sucedida.</span><span class="sxs-lookup"><span data-stu-id="df7c8-232">This can be useful if execution of the operation failed but the interceptor wishes EF to continue as if the operation had succeeded.</span></span> <span data-ttu-id="df7c8-233">Isso geralmente também envolve a definição do resultado para que o EF tenha algum valor de resultado para trabalhar enquanto continua.</span><span class="sxs-lookup"><span data-stu-id="df7c8-233">This usually also involves setting the Result so that EF has some result value to work with as it continues.</span></span>  

#### <a name="originalresult-and-originalexception"></a><span data-ttu-id="df7c8-234">OriginalResult e OriginalException</span><span class="sxs-lookup"><span data-stu-id="df7c8-234">OriginalResult and OriginalException</span></span>  

<span data-ttu-id="df7c8-235">Depois que o EF tiver executado uma operação, ele definirá as propriedades Result e OriginalResult se a execução não falhar ou a exceção e as propriedades OriginalException se a execução falhar com uma exceção.</span><span class="sxs-lookup"><span data-stu-id="df7c8-235">After EF has executed an operation it will set either the Result and OriginalResult properties if execution did not fail or the Exception and OriginalException properties if execution failed with an exception.</span></span>  

<span data-ttu-id="df7c8-236">As propriedades OriginalResult e original são somente leitura e só são definidas pelo EF depois de realmente executar uma operação.</span><span class="sxs-lookup"><span data-stu-id="df7c8-236">The OriginalResult and OriginalException properties are read-only and are only set by EF after actually executing an operation.</span></span> <span data-ttu-id="df7c8-237">Essas propriedades não podem ser definidas por interceptores.</span><span class="sxs-lookup"><span data-stu-id="df7c8-237">These properties cannot be set by interceptors.</span></span> <span data-ttu-id="df7c8-238">Isso significa que qualquer interceptador pode distinguir entre uma exceção ou resultado que foi definido por outro interceptador, em oposição à exceção real ou resultado que ocorreu quando a operação foi executada.</span><span class="sxs-lookup"><span data-stu-id="df7c8-238">This means that any interceptor can distinguish between an exception or result that has been set by some other interceptor as opposed to the real exception or result that occurred when the operation was executed.</span></span>  

### <a name="registering-interceptors"></a><span data-ttu-id="df7c8-239">Registrando interceptores</span><span class="sxs-lookup"><span data-stu-id="df7c8-239">Registering interceptors</span></span>  

<span data-ttu-id="df7c8-240">Depois que uma classe que implementa uma ou mais das interfaces de interceptação tiver sido criada, ela poderá ser registrada com o EF usando a classe DbInterception.</span><span class="sxs-lookup"><span data-stu-id="df7c8-240">Once a class that implements one or more of the interception interfaces has been created it can be registered with EF using the DbInterception class.</span></span> <span data-ttu-id="df7c8-241">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="df7c8-241">For example:</span></span>  

``` csharp
DbInterception.Add(new NLogCommandInterceptor());
```  

<span data-ttu-id="df7c8-242">Os interceptores também podem ser registrados no nível de domínio do aplicativo usando o mecanismo de configuração com base em código DbConfiguration.</span><span class="sxs-lookup"><span data-stu-id="df7c8-242">Interceptors can also be registered at the app-domain level using the DbConfiguration code-based configuration mechanism.</span></span>  

### <a name="example-logging-to-nlog"></a><span data-ttu-id="df7c8-243">Exemplo: registrando em log no NLog</span><span class="sxs-lookup"><span data-stu-id="df7c8-243">Example: Logging to NLog</span></span>  

<span data-ttu-id="df7c8-244">Vamos reunir tudo isso em um exemplo que usa IDbCommandInterceptor e [NLog](https://nlog-project.org/) para:</span><span class="sxs-lookup"><span data-stu-id="df7c8-244">Let’s put all this together into an example that using IDbCommandInterceptor and [NLog](https://nlog-project.org/) to:</span></span>  

- <span data-ttu-id="df7c8-245">Registrar um aviso para qualquer comando executado de forma não assíncrona</span><span class="sxs-lookup"><span data-stu-id="df7c8-245">Log a warning for any command that is executed non-asynchronously</span></span>  
- <span data-ttu-id="df7c8-246">Registrar um erro para qualquer comando que é acionado quando executado</span><span class="sxs-lookup"><span data-stu-id="df7c8-246">Log an error for any command that throws when executed</span></span>  

<span data-ttu-id="df7c8-247">Aqui está a classe que faz o registro em log, que deve ser registrado como mostrado acima:</span><span class="sxs-lookup"><span data-stu-id="df7c8-247">Here’s the class that does the logging, which should be registered as shown above:</span></span>  

``` csharp
public class NLogCommandInterceptor : IDbCommandInterceptor
{
    private static readonly Logger Logger = LogManager.GetCurrentClassLogger();

    public void NonQueryExecuting(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void NonQueryExecuted(
        DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ReaderExecuting(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ReaderExecuted(
        DbCommand command, DbCommandInterceptionContext<DbDataReader> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    public void ScalarExecuting(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfNonAsync(command, interceptionContext);
    }

    public void ScalarExecuted(
        DbCommand command, DbCommandInterceptionContext<object> interceptionContext)
    {
        LogIfError(command, interceptionContext);
    }

    private void LogIfNonAsync<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (!interceptionContext.IsAsync)
        {
            Logger.Warn("Non-async command used: {0}", command.CommandText);
        }
    }

    private void LogIfError<TResult>(
        DbCommand command, DbCommandInterceptionContext<TResult> interceptionContext)
    {
        if (interceptionContext.Exception != null)
        {
            Logger.Error("Command {0} failed with exception {1}",
                command.CommandText, interceptionContext.Exception);
        }
    }
}
```  

<span data-ttu-id="df7c8-248">Observe como esse código usa o contexto de interceptação para descobrir quando um comando está sendo executado de forma não assíncrona e descobrir quando ocorreu um erro ao executar um comando.</span><span class="sxs-lookup"><span data-stu-id="df7c8-248">Notice how this code uses the interception context to discover when a command is being executed non-asynchronously and to discover when there was an error executing a command.</span></span>  
